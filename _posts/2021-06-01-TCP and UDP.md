---
layout: post
title: "[네트워크] TCP와 UDP"
subtitle: "IT 엔지니어를 위한 네트워크 입문"
date: 2021-06-01 23:27:00 +0900
background: '/img/posts/cable.jpg'
category: Study
tags: [network]
---
## 3.4 TCP와 UDP
2, 3계층의 목적
* 목적지를 정확히 찾아가기 위한 주소 제공

4계층에서 동작하는 프로토콜의 목적
* 목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가게 하는 것
* 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할

실제 서비스는 출발지에서 목적지까지의 경로를 찾는 것에서 끝이 아니라 정상적으로 돌아가기 위한 다양한 작업에 문제가 없어야 정상적인 서비스를 제공할 수 있습니다.

### 3.4.1 4계층 프로토콜(TCP, UDP)과 서비스 포트
인캡슐레이션과 디캡슐레이션에서 각 계층에서 정의하는 헤더가 추가되고, 여러 정보가 들어갑니다.

다양한 정보 중 가장 중요한 두 가지는 

* 각 계층에서 정의하는 정보
* 상위 프로토콜 지시자 정보

입니다.

##### 각 계층에서 정의하는 정보
각 계층에서 정의하는 정보는 수신 측의 동일 계층에서 사용하기 위한 정보입니다.

예시
* 송신 측에서 추가한 2계층 헤더의 **MAC 주소 정보**는 수신 측 2계층에서 확인하고 사용됩니다.
* 송신 측에서 추가한 3계층 **IP 주소**는 수신 측 3계층에서 사용합니다.

4계층에선 이런 정보로 **시퀀스 번호, ACK 번호**가 있습니다.

##### 상위 프로토콜 지시자 정보
상위 프로토콜 지시자 정보는 **디캡슐레이션** 과정에서 **상위 계층의 프로토콜이나 프로세스**를 정확히 찾아가기 위한 목적으로 사용됩니다.

* 2계층: 이더 타입
* 3계층: 프로토콜 번호
* 4계층: 포트 번호

<img class="img-fluid" src="/img/posts/inPost/header.png">
<span class="caption text-muted">각 계층에서 정의하는 정보와 상위 프로토콜 지시자</span>

TCP/IP 프로토콜 스택의 4계층은 TCP와 UDP가 담당합니다.

4계층의 목적은 다음과 같습니다.

1. 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 
2. 데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것

패킷을 잘 분할/조립하기 위해 TCP 프로토콜에선 **시퀀스 번호와 ACK 번호**를 사용합니다.

위의 헤더에 저장된 정보를 나타낸 표를 보면, 상위 프로토콜 지시자가 2, 3계층에선 출발지와 도착지를 구분하지 않고 하나만 사용하지만 4계층에선 출발지 포트 번호와 목적지 포트 번호를 구분해 처리합니다.

일반적으로 TCP/IP에서 클라이언트-서버 방식으로 서비스를 제공하고 클라이언트용 프로그램-서버용 프로그램을 구분해 개발하기 때문입니다.

##### 예시
```클라이언트 (서비스 요청)```

|출발지 포트|목적지 포트|
|---|---|
|13959|80|

*****

```서버 (서비스 응답)```

|출발지 포트|목적지 포트|
|---|---|
|80|13959|

*****

서버 측에서 클라이언트 측의 요청에 대한 응답을 할 때는 출발지 포트가 서버의 포트, 도착지 포트가 클라이언트의 포트가 되어 전송됩니다.

##### 포트 번호 할당

평소 우리가 표현하는 포트 번호의 기준은 서버의 포트입니다.

* HTTP TCP 80
* HTTPS TCP 443
* SMTP TCP 25

위와 같이 잘 알려진 포트를 웰 노운(Well Known) 포트라고 합니다.

이 포드들은 이미 인터넷 주소 할당기구인 IANA(Internet Assigned Number Authority)에 등록되고 1023번 이하의 포트 번호를 사용합니다.

다양한 애플리케이션에 포트 번호를 할당하기 위해 Registered Port 범위를 사용합니다.
* 1024 ~ 49151의 번위
* 포트 번호를 할당받기 위해 IANA에 등록되어 관리되지만 공식 번호와 비공식 번호가 혼재되어 있고 사설 포트 번호로 사용되기도 합니다.

동적, 사설, 임시 포트
* 49152 ~ 65535
* 이 범위의 포트 번호는 IANA에 등록되어 사용되지 않습니다.
* 이 포트 번호는 자동 할당되거나 사설 용도로 할당되고 클라이언트의 임시 포트 번호로 사용됩니다.

### 3.4.2 TCP
TCP 프로토콜은 신뢰할 수 없는 공용망에서도 **정보유실 없는 통신을 보장**하기 위해 

1. 세션을 안전하게 연결하고 
2. 데이터를 분할하고 
3. 분할된 패킷이 잘 전송되었는지 확인

하는 기능이 있습니다.

패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Acknowledge Numebr)합니다. 또, 수신자가 안정적으로 처리할 수 있는 전송 크기(Window Size)까지 고려해 통신합니다.

> TCP의 여러 역할 덕분에 네트워크 상태를 심각하게 고려하지 않고 쉽고 안전하게 네트워크를 사용할 수 있습니다.

#### 3.4.2.1 패킷 순서, 응답 번호
TCP는 분할된 패킷을 잘 분할하고 수신 측이 잘 조합하도록 **패킷에 순서**를 주고 **응답 번호**를 부여합니다.

패킷에 부여한 순서가 **시퀀스 번호**이고, 응답 번호가 **ACK 번호**입니다.

두 번호의 상호작용에 의해 순서가 바뀌거나 패킷이 유실되는 것을 파악할 수 있습니다.

* 보내는 쪽에서 패킷에 번호를 부여하고 받는 쪽은 이 번호의 순서가 맞는지 확인합니다.
* 받은 패킷 번호가 맞으면 응답을 주는데 이때 다음 번호의 패킷을 요청합니다. 이 숫자를 ACK 번호라 합니다.

<img class="img-fluid" src="/img/posts/inPost/tcp-01.png">
<span class="caption text-muted">시퀀스 번호와 ACK 번호의 기본 동작 방식</span>

#### 3.4.2.2 윈도 사이즈와 슬라이딩 윈도
TCP는 패킷을 보낸 후 상대방이 잘 받았는지 확인하기 위해 ACK 번호를 확인하고 다음 패킷을 전송합니다.

패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신 시간을 늘립니다. 추가적으로 송신자와 수신지가 멀리 떨어져 있으면 왕복 지연시간이 늘어나므로 응답을 기다리는 시간이 더 길어집니다.

최대 효율을 위해 최대한 한꺼번에 많은 패킷을 보내고, 응답을 하나만 받습니다.

하지만 네트워크 상태가 좋지 않으면 패킷 유실 가능성이 커지므로 적절한 송신량을 결정해야 하는데 **한 번에 데이터를 받을 수 있는 데이터 크기를 윈도 사이즈**라고 하고 네트워크 상황에 따라 이 윈도 사이즈를 조절하는 것을 **슬라이딩 윈도**라고 합니다.

<img class="img-fluid" src="/img/posts/inPost/tcp-02.png">

TCP 헤더에서 윈도 사이즈로 표현할 수 있는 최대 크기는 2^16입니다.
* 실제로 64K만큼 윈도 사이즈를 가질 수 있지만 이 사이즈는 회선의 안정성이 높아지고 고속화되는 현대 네트워크에서는 너무 작은 숫자입니다.
* TCP 헤더는 변경이 불가능하므로 헤더 사이즈를 늘리지 않고 뒤의 숫자를 무시하는 방법으로 윈도 사이즈를 증가시켜 통신합니다.

이런 방법을 사용하면 기존 숫자의 10배, 100배로 윈도 사이즈가 커집니다.

***

TCP는 데이터에 유실이 발생하면 윈도 사이즈를 절반으로 떨어뜨리고 정상적인 통신이 되는 경우, 서서히 하나씩 늘립니다.

네트워크에 경합이 발생해 패킷 드롭이 생기면 작아진 윈도 사이즈로 인해 데이터 통신 속도가 느려져 회선을 제대로 사용하지 못하는 상황이 발생할 수 있습니다.

* 경합을 피하기 위해 회선 속도를 증가
* 경합을 임시로 피하게 할 수 있는 버퍼가 큰 네트워크 장비 사용
* TCP 최적화 솔루션을 사용

위와 같은 방법을 사용해 문제를 해결할 수 있습니다.

#### 3.4.2.3 3방향 핸드셰이크
TCP에선 유실없는 안전한 통신을 위해 통신 시작 전, 사전 연결작업을 진행합니다.

TCP 프로토콜은 통신 전, 데이터를 안전하게 보내고 받을 수 있는지 미리 확인하는 작업을 거칩니다.   
**목적지가 데이터를 받을 준비가 안 된 상황에서 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가 버려지기 때문입니다.**

TCP에서는 3번의 패킷을 주고받으며 통신을 서로 준비합니다. (3way handshake)
> 패킷 네트워크에선 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서는 통신 전, 각 통신에 필요한 리소스를 미리 확보하는 작업이 중요합니다. 

***

TCP는 3방향 핸드셰이크 진행 상황에 따라 상태 정보를 부르는 이름이 다릅니다.

1. 서버는 서비스를 제공하기 위해 클라이언트의 접속을 받아들일 수 있는 **LISTEN** 상태로 대기합니다.
2. 클라이언트에서 통신을 시도할 때 SYN 패킷을 보내는데 클라이언트에서는 이 상태를 **SYN-SENT**라고 부릅니다.
3. 서버는 SYN을 받고 **SYN-RECEIVED** 상태로 변경되고 SYN, ACK로 응답합니다.
4. 이 응답을 받은 클라이언트는 **ESTABLISHED** 상태로 변경하고 그에 대한 응답을 서버로 다시 보냅니다.
    * ESTABLISHED 상태는 서버와 클라이언트 간의 연결이 성공적으로 완료되었음을 나타냅니다.

> Syn, Ack는 플래그의 종류로 아래에 나옵니다.

<img class="img-fluid" src="/img/posts/inPost/tcp-03.png">
<span class="caption text-muted">3방향 핸드셰이크</span>

***

3방향 핸드셰이크 과정이 생기면서 기존 통신과 새로운 통신을 구분해야 합니다.

어떤 패킷이 새로운 연결 시도이고 기존 통신에 대한 응답인지 구분하기 위해 헤더에 플래스(Flag)라는 값을 넣어 통신합니다.

<img class="img-fluid" src="/img/posts/inPost/tcp-04.png">
<span class="caption text-muted">TCP 헤더 내용. 컨트롤 비트는 총 6비트이고 각 비트가 1인 경우, 해당 내용을 나타낸다.</span>

Flag의 종류는 다음의 6가지 입니다.

##### SYN
연결의 시작 용도로 사용합니다. 연결이 시작될 때 SYN 플래그에 1로 표시해 보냅니다.

##### ACK
ACK 번호가 유효할 경우, 1로 표시해 보냅니다.

초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답이므로 ACK 플래그가 1로 표기됩니다.

##### FIN
연결 종료 시 1로 표시됩니다. 데이터 전송을 마친 후 정상적으로 양방향 종료 시 사용됩니다.

##### RST
연결 종료 시 1로 표시됩니다. 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용됩니다.

##### URG
긴급 데이터인 경우, 1로 표시해 보냅니다.

##### PSH
서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때 사용됩니다.

<img class="img-fluid" src="/img/posts/inPost/tcp-05.png">
<span class="caption text-muted">3방향 핸드셰이크</span>

1. 통신 시작 - 연결 시도
    * 송신자는 플래그의 SYN 필드를 1로 표기해 패킷 전송
    * 이때 자신이 사용할 첫 시퀀스 번호를 적어 보냄
2. 수신 & 응답 - 연결 시도 허락
    * 수신자는 SYN과 ACK 플래그에 1로 표기해 응답
        * 자신이 처음으로 보내는 패킷이니 SYN을 1로 표기
        * 송신자가 보냈던 패킷의 응답이기도 하므로 ACK에 1로 표기 
    * 자신이 사용할 시퀀스 번호를 적고, **송신자가 보낸 시퀀스 번호에 1을 추가한 값을 ACK 번호에 넣어** 응답
        * 송신자가 보낸 10번까지 잘 받았으니 다음엔 시퀀스 번호 10+1을 달라는 의미
    * 이 패킷은 송신자의 연결 시도를 허락하는 의미로 사용됩니다.
3. 연결 확립
    * 수신자의 응답을 받은 송신자는 연결을 확립하기 위해 다시 한 번 응답 메시지를 보냅니다.
    * 기존 메시지의 응답이므로 ACK 필드만 1로 표기
    * 수신자가 보낸 시퀀스 번호에 1을 더해 ACK 번호에 넣어 응답
        * 20까지 잘 받았으니 시퀀스 번호 20+1을 보내 달라는 의미

*****

### 3.4.3 UDP
TCP와 달리 UDP는 4계층 프로토콜에서 가져야 할 특징이 거의 없습니다.

4계층에서는 신뢰성 있는 통신을 위해...

* 연결을 미리 확립했고 데이터를 잘 분할하고 조립하기 위해 패킷 번호를 부여하고 수신된 데이터에 대해 응답하는 작업을 수행했습니다. 
* 데이터를 특정 단위(윈도 사이즈)로 보내고 메모리에 유지하다가 ACK 번호를 받은 후 통신이 잘 된 상황을 파악하고나서야 메모리에서 이 데이터들을 제거했습니다.
* 중간에 유실이 있으면 시퀀스 번호와 ACK 번호를 비교해가며 이를 파악하고 메모리에 유지해놓은 데이터를 이용해 재전송하는 기능이 있었습니다.

이런 특징들로 신뢰성 있는 통신을 수행하는 것은 TCP만 해당됩니다.

UDP에는 이런 기능이 전혀 없습니다.

<img class="img-fluid" src="/img/posts/inPost/udp-01.png">
<span class="caption text-muted">UDP의 헤더. 신뢰 통신을 위한 내용이 없다.</span>

UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용됩니다.

##### 시간에 민감한 프로토콜이나 애플리케이션을 사용하는 경우
* 음성 데이터
* 실시간 스트리밍

##### 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경
* 사내 방송이나 증권 시세 데이터 전송에 사용되는 멀티캐스트

위는 응답 시간에 민감한 경우입니다.

실 세계 데이터를 디지털화할 때는 시간을 다른 일반 데이터처럼 취급하면 시간 지연에 따른 어려움이 발생합니다.

> 중간에 데이터 몇 개쯤 유실되는 것보다 재전송하기 위해 잠시 동영상이나 음성이 멈추는 것을 사용자는 네트워크 품질이 떨어진다고 느낄 수 있습니다.

> 30프레임 동영상에서 1프레임이 잘린 29프레임만으로도 사람들의 눈에는 이질감이 없지만 프레임을 재전송하기 위해 일싲거으로 화면이 멈출 경우, 사용자는 네트워크 품질이 떨어진다고 느낍니다.

이렇게 데이터를 전송하는 데 신뢰성보다 일부 데이터가 유실되더라도 시간에 맞추어 계속 전송하는 것이 중요한 화상회의 시스템과 같은 서비스인 경우, UDP를 사용하게 됩니다.

*****

UDP는 TCP의 3방향 핸드셰이크와 같이 통신 전, 연결을 확립하는 절차가 없습니다.

그대신 UDP에서 첫 데이터는 리소스를 확보하기 위해 인터럽트(Interrupt)를 거는 용도로 사용되고 유실됩니다.

그래서 UDP 프로토콜을 사용하는 애플리케이션 대부분이 이런 상황을 인지하고 동작하거나 연결 확립은 TCP 프로토콜을 사용하고 애플리케이션끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분입니다.

#### TCP와 UDP 비교

|TCP|UDP|
|---|---|
|연결 지향(Connection Oriented)|비연결형(Connectionless)|
|오류 제어 수행|오류 제어 수행 안 함|
|흐름 제어 수행|흐름 제어 수행 안 함|
|유니캐스트|유니캐스트, 멀티캐스트, 브로드캐스트|
|전이중(Full Duplex)|반이중(Half Duplex)|
|데이터 전송|실시간 트래픽 전송|

*****

> * 전이중: 쌍방향 통신으로 두 지점 사이에서 정보를 주고 받는 전자 통신 시스템
> * 반이중: 한 쪽이 송신하는 동안 다른 쪽에서 수신하는 통신 방식으로, 전송 방향을 교체한다. 마스터 슬레이브 방식의 센서 네트워크가 대표적이다.

>참조: https://ko.wikipedia.org/wiki/%EC%9D%B4%EC%A4%91%ED%86%B5%EC%8B%A0

*****

### 끝
[IT 엔지니어를 위한 네트워크 입문] 도서를 참조해 공부한 내용입니다.

감사합니다.

<p class = "placeholder">Photographs by Chaelin, Unsplash.</p>